import os, sys, json, copy
from task import Task
from id_gen import increment_id
from globals import *

class Master:
    ''' Manages I/O operations and Task objects. '''
    def __init__(self, ui):
        self.ui = ui

        self.SCRIPT_DIR = self._get_script_dir()
        self.STORAGE_PATH = os.path.join(self.SCRIPT_DIR, "storage.json")

        self.data = {}

    def _deep_remove_task(self, task_id):
        ''' Removes task with ID task_id from Master.data["tasks"], then iterates through
        all tasks in the dict and removes task with ID task_id from any parents or subtasks
        lists.

        If the task is parent to any other tasks those subtasks are removed as well,
        recursively.
         
        This function is intended as fallback for Master.remove_task() (and is potentially slower)
        as well as for use when data corruption is suspected (for example, a non-existent task ID 
        remaining in a parents or subtasks list).
        '''

        to_remove = set()
        taskd_keys = TASKD_TEMPLATE.keys()

        for _task_id, _task in copy.copy(self.data["tasks"]).items():
            if task_id == _task_id:
                pass
            
            if isinstance(_task, Task):
                _task.remove_subtask(task_id)

                if task_id in _task.get_parents(): 
                    to_remove.add(_task_id)

                    for __task_id in _task.get_subtasks():
                        to_remove.add(__task_id)
            elif isinstance(_task, dict):
                if _task.keys() != taskd_keys:
                    to_remove.add(_task_id)
                    continue

                if task_id in _task[TSK_SUBTASKS]:
                    _task[TSK_SUBTASKS].remove(task_id)

                if task_id in _task[TSK_PARENTS]:
                    to_remove.add(_task_id)

                    for __task_id in _task[TSK_SUBTASKS]:
                        to_remove.add(__task_id)
            else:
                to_remove.add(_task_id)
                
        try:
            self.data["tasks"].pop(task_id) 
        except KeyError: # A nonexistent task, most likely from a subtasks or parents list.
            pass

        for _task_id in to_remove:
            for group_id in self.data["groups"]:
                self.group_remove_task(_task_id, group_id)
            self._deep_remove_task(_task_id)

    def _get_script_dir(self):
        ''' Get the directory of the file that Master object is created from. '''
        dirname, _ = os.path.split(__file__)
        return os.path.abspath(dirname)

    def _groups_task_ids_to(self, type, data):
        ''' Converts task IDs in a group to set or list. '''
        
        if not (type == set or type == list):
            raise TypeError(f"Invalid type provided: {type}") 

        for group_id in data["groups"].keys():
            data["groups"][group_id]["task_ids"] = type(data["groups"][group_id]["task_ids"])

    def _is_Task(self, task_id):
        ''' Confirms if task ID is a Task object. 
        
        Raises:
            TaskNotFoundError
        '''
        try:
            if isinstance(self.data["tasks"][task_id], Task):
                return True
            else:
                return False
        except KeyError as e:
            raise TaskNotFoundError(task_id=task_id, e=e)

    def _set_current_id(self, id, type, validate_id=True):
        ''' Sets current task ID or group ID based on provided type. 

            Expected args:
                id: base36-int
                type: str == ["group" | "task"]
                
            validate_id specifis if validation of the provided ID should be performed.
            Unless ID was generated by Master or Task validation is recommended.
        '''
        if validate_id:
            Task._validate_id(Task, id)

        if type == "task":
            key = "current_task_id"
        elif type == "group":
            key = "current_group_id"

        self.data[key] = id
        
    def _set_current_task_id(self, task_id, validate_id=True):
        ''' Set current ID to 'id'. '''        
        self._set_current_id(task_id, "task", validate_id=validate_id)

    def _set_current_group_id(self, group_id, validate_id=True):
        self._set_current_id(group_id, "group", validate_id=validate_id)

    def create_group(self, title=None):
        ''' Creates a new group and returns its group ID. '''

        group_id = increment_id(self.get_current_group_id())
        self.data["groups"][group_id] = copy.deepcopy(GROUP_TEMPLATE)

        self._set_current_group_id(group_id, validate_id=False)

        return group_id

    def create_subtask(self, parent_task_id, task_kwargs={}):
        ''' Creates a Task object and adds task ID to subtask 
        attribute of Task object with ID parent_task_id. 
        
        Returns task ID on completion.

        Raises:
            TaskCreationError
            TaskNotFoundError
        '''

        task_id = self.create_task(subtask=True, task_kwargs=task_kwargs)

        try:
            self.load_task(parent_task_id)
        except TaskNotFoundError as e:
            e.msg = f"Could not make '{task_id}' a subtask of task with ID '{parent_task_id}'.\nAttempting to remove task with ID: '{task_id}'."
            self.remove_task(task_id)        
            raise

        self.data["tasks"][task_id].add_parent(parent_task_id)
        self.data["tasks"][parent_task_id].add_subtask(task_id)

        return task_id

    def create_task(self, group_id=None, subtask=False, task_kwargs={}):
        ''' Creates a Task object with args in task_kwargs and returns task ID on success. 
        
        Raises:
            GroupNotFoundError
            TaskCreationError
        '''
        if "task_id" in task_kwargs.keys():
            raise TaskCreationError(task_id=task_kwargs["task_id"],
                                    msg="Cannot create task with excplicit task ID. Interact with Task object directly to achieve this, or use Master.load_task() to load an existing task with provided ID.")
        
        if group_id and subtask:
            raise TaskCreationError(task_id=increment_id(self.get_current_task_id()), 
                                    msg="Argument Error: A task cannot be both a subtask and part of a group.")

        try:
            task = Task(master=self, **task_kwargs)
        except (TypeError, ValueError) as e:
            raise TaskCreationError(task_id=increment_id(self.get_current_task_id()), 
                                    e=e,
                                    msg=f"Error with argument passed to Task.__init__(): '{task_kwargs}'.:\nDescription: {e}")

        task_id = task.get_id()
        self.data["tasks"][task_id] = task

        if group_id:
            try:
                self.group_add_task(task_id, group_id)
            except GroupNotFoundError as e:
                e.task_id = task_id
                e.msg += f"\nTask with ID '{task_id}' was created but not succesfully added to any group."
                raise
            
        return task_id

    def get_active_group(self):
        return self.data["active_group"]
    
    def get_current_task_id(self):
        return self.data["current_task_id"]

    def get_current_group_id(self):
        return self.data["current_group_id"]

    def get_group_tasks(self, group_id):
        ''' Returns a list of task IDs in group. 
        
        Raises:
            GroupNotFoundError
        '''
        try:
            task_ids = self.data["groups"][group_id]["task_ids"]
        except KeyError as e:
            raise GroupNotFoundError(group_id=group_id, e=e)
        
        return list(task_ids)

    def get_groups(self):
        ''' Returns a list of group IDs. '''
        return list(self.data["groups"].keys())
    
    def get_task(self, task_id):
        ''' Loads and returns Task object with ID task_id. 
        
        Raises:
            TaskNotFoundError
        '''
        
        self.load_task(task_id)

        return self.data["tasks"][task_id]

    def get_tasks(self):
        ''' Returns a list of all task IDs. '''
        return list(self.data["tasks"].keys())

    def group_add_task(self, task_id, group_id): 
        ''' Adds an existing task ID to a group. 
        
        Raises: 
            GroupNotFoundError
            TaskNotFoundError
            ValueError
        '''
        error_message = f"Failed to add task with ID '{task_id}' to group with ID '{group_id}'."

        try:
            task = self.get_task(task_id)
        except TaskNotFoundError as e:
            raise TaskNotFoundError(e=e, task_id=task_id, msg=error_message) from e

        if task.get_parents(): # Todo: raise appropriate error
            raise ValueError(f"{error_message} A subtask cannot be part of a group.")

        try:        
            self.data["groups"][group_id]["task_ids"].add(task_id)
        except KeyError as e:
            raise GroupNotFoundError(group_id=group_id, 
                                     task_id=task_id, 
                                     msg=error_message, 
                                     e=e)

    def group_remove_task(self, task_id, group_id):
        ''' Removes a task from a group. 
        
        Raises:
            GroupNotFoundError
        '''
        try:
            group = self.data["groups"][group_id]
        except KeyError as e:
            raise GroupNotFoundError(group_id=group_id, e=e)
        
        try:
            group["task_ids"].remove(task_id)
        except KeyError: # Task is not in group
            return

    def init_storage_file(self):
        ''' Initializes (and if not exists, creates) the storage file. 
        
        Raises:
            DataError
            FSError
        '''

        group = copy.deepcopy(GROUP_TEMPLATE)
        group["title"] = "General"
        group["task_ids"] = list(group["task_ids"])

        storage = {
            "current_task_id": "0", # IDs are in base 36, hence strings
            "current_group_id": "0",
            "active_group": "0",
            "groups": {"0": group},
            "tasks": {} 
        }

        try:
            with open(self.STORAGE_PATH, "w") as f:
                f.write(json.dumps(storage, ensure_ascii=False))
        except FileNotFoundError as e:
            raise FSError(e=e, path=self.STORAGE_PATH, msg="A file system error occured during creation of storage file.")
        except PermissionError as e:
            raise FSError(e=e, path=self.STORAGE_PATH, msg=f"No permission to create storage file. Inspect file permissions for: '{self.STORAGE_PATH}'")

        with open(self.STORAGE_PATH, "r") as f:
            try:
                written = json.loads(f.read())
            except json.JSONDecodeError as e:
                raise DataError(path=self.STORAGE_PATH, 
                                msg="An error occured while creating storage file.",
                                e=e)

            if written == storage:
                self.ui.relay(f"Succesfully initialized storage file at '{self.STORAGE_PATH}'.")
            else:
                raise DataError(path=self.STORAGE_PATH, msg=f"Expected: {storage}\nActual: {written}")

    def load_data(self):
        ''' Loads from storage file to self.data. 
        
        Raises:
            DataError
            FSError
        '''

        data = {}

        try:
            with open(self.STORAGE_PATH, mode='r') as f:
                data = json.loads(f.read())
        except FileNotFoundError as e:
            self.ui.relay(f"Storage file at '{self.STORAGE_PATH}' not found.")
        except json.JSONDecodeError as e:
            raise DataError(e=e, path=self.STORAGE_PATH, msg="The data in storage file could not be interpreted.")
        except PermissionError as e:
            raise FSError(e=e, path=self.STORAGE_PATH, msg=f"No permission to access storage file. Inspect file permissions for: '{self.STORAGE_PATH}'")
        except Exception as e:
            raise FSError(e=e, path=self.STORAGE_PATH, msg="An unexpected error occurred while loading data.")

        if data:
            self.STORAGE_BACKUP = copy.deepcopy(self.data)

            self._groups_task_ids_to(set, data)
            self.data = data
        else:
            self.ui.relay(message=f"No data loaded from storage file at: '{self.STORAGE_PATH}'.")
            self.ui.relay(message="Attempting to create a new storage file...")

            self.init_storage_file()
            self.load_data()

    def load_group(self, group_id):
        ''' Converts task dicts to Task objects for tasks in group with ID group_id. 
        
        Raises:
            GroupNotFoundError
        '''        
        
        task_ids = self.get_group_tasks(group_id)
        
        for task_id in task_ids:
            try:
                self.load_task(task_id)
            except TaskNotFoundError:
                self.group_remove_task(task_id, group_id)
                continue

    def load_task(self, task_id):
        ''' Converts task dict to Task object for task with ID task_id. 
        
        Recursively loads parent and subtasks.
        
        Raises:
            TaskNotFoundError
        '''
        
        if self._is_Task(task_id):
            return

        try:
            task = Task(self, 
                        task_id=task_id, 
                        taskd=self.data["tasks"][task_id])
        except (TypeError, ValueError) as e:
            raise DataError(task_id=increment_id(self.get_current_task_id()), 
                                e=e,
                                msg=f"Data in loaded task dict with ID '{task_id}' was invalid.\nDescription: {e}")

        self.data["tasks"][task_id] = task
        
        for subtask_id in self.data["tasks"][task_id].get_subtasks():
            self.load_task(subtask_id)

        for parent_id in self.data["tasks"][task_id].get_parents():
            self.load_task(parent_id)
        
    def orphan_task(self, task_id):
        ''' Removes a task from all parents' subtask attribute. 

        Raises:
            TaskNotFoundError
        '''
        self.load_task(task_id)
        
        for parent_id in self.data["tasks"][task_id].get_parents():
            self.data["tasks"][parent_id].remove_subtask(task_id)

    def remove_task(self, task_id, subtask=False):
        ''' Removes a task from all groups, orphans the task 
        and recursively removes all of its subtaskts.

        Raises:
            TaskNotFoundError
        '''

        if not subtask:
            for group_id in self.data["groups"].keys():
                self.group_remove_task(task_id, group_id)

        try:
            self.load_task(task_id)
        except (TaskNotFoundError, DataError) as e: 
            # Indicates failure to load task (OR its parents/subtasks, which indicates data corruption).
            self._deep_remove_task(task_id)
            raise type(e)(msg=f"An attempt has been made to remove mention of task with ID '{task_id}' from groups, parents and subtasks lists and all of its children (if any).", 
                          task_id=e.task_id, 
                          e=e) from e

        self.orphan_task(task_id)
        
        for subtask_id in self.data["tasks"][task_id].get_subtasks():
            try:
                self.remove_task(subtask_id, subtask=True)
            except TaskNotFoundError:
                pass

        self.data["tasks"].pop(task_id)
    
    def remove_group(self, group_id):
        ''' Removes group with group ID group_id. Tasks are left without a group unless explicitly moved first. '''
        try:
            self.data["groups"].pop(group_id)
        except KeyError as e:
            raise GroupNotFoundError(e=e, 
                                     group_id=group_id, 
                                     msg=f"Unable to remove group with ID: '{group_id}'.") from e

    def set_active_group(self, group_id):
        ''' Sets the active group, loading all of its tasks. 
        
        Raises:
            GroupNotFoundError
        '''

        if self.get_active_group() != group_id:
            self.load_group(group_id)

            self.data["active_group"] = group_id
            
    def write_data(self): 
        ''' Writes self.data to storage file. 
        
        Raises:
            FSError
        '''

        data = copy.deepcopy(self.data)

        self._groups_task_ids_to(list, data)

        for task_id, task in self.data["tasks"].items(): # Todo: make function using own getters instead of raw dict access.
            if self._is_Task(task_id):    
                data["tasks"][task_id] = task.write_dict()
        
        try:
            with open(self.STORAGE_PATH, mode='w') as f:
                json.dump(data, f) # ? Is ensure_ascii=True necessary?
        except FileNotFoundError as e:
            raise FSError(e=e, path=self.STORAGE_PATH, msg=f"No file found at: '{self.STORAGE_PATH}'")
        except PermissionError as e:
            raise FSError(e=e, path=self.STORAGE_PATH, msg=f"No permission to write to storage file. Inspect file permissions for: '{self.STORAGE_PATH}'")
        except Exception as e:
            raise FSError(e=e, path=self.STORAGE_PATH, msg=f"An unexpected error occured during attempt to write data to storage file at: '{self.STORAGE_PATH}'")

        pass # Todo: check for write success
        # if success, create a new backup with self.STORAGE_BACKUP = copy.deepcopy(data)
        
if __name__ == '__main__':
    class DevUI:
        ''' Simple frontend for development purposes. 
        
        Serves as example for other frontends. Frontends must define the function headers defined here.   
        '''

        def relay(self, message=''):
            ''' Relays a message to the user. '''
            print(message)
        
        def request(self, request_type=bool, message=''):
            ''' Requests information from the user. '''
            def prompt_user(prompt):
                u_in = ''
                while not u_in:
                    u_in = input(prompt)
                return u_in

            print("Please provide:", message)

            if request_type is bool:
                if prompt_user("(Y/n)> ").lower().startswith('y'):
                    return True
                else:
                    return False
            elif request_type is str:                
                return prompt_user("> ")
            elif request_type is int:
                u_in = ''
                while not u_in.isdecimal():
                    u_in = prompt_user("> ")
                return int(u_in)

    master = Master(DevUI())