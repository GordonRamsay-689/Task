import os, json, copy
from task import Task
from id_gen import increment_id
from globals import *

class Master:
    ''' Manages I/O operations and Task objects. '''
    def __init__(self, ui):
        self.ui = ui

        self.SCRIPT_DIR = self._get_script_dir()
        self.STORAGE_PATH = os.path.join(self.SCRIPT_DIR, "storage.json")

        self.data = {}
    
    def _convert_to_dict(self, task_id):
        ''' Converts a Task object to a task dictionary.

        Raises:
            TaskNotFoundError
        '''
        task_dict = self.get_task(task_id).write_dict()
        self.data[DATA_TASKS][task_id] = task_dict

    def _deep_remove_task(self, task_id):
        ''' Removes task with ID task_id from Master.data[DATA_TASKS], then iterates through
        all tasks in the dict and removes task with ID task_id from any parents or subtasks
        lists.

        If the task is parent to any other tasks those subtasks are removed as well,
        recursively.
         
        This function is intended as fallback for Master.remove_task() (and is potentially slower)
        as well as for use when data corruption is suspected (for example, a non-existent task ID 
        remaining in a parents or subtasks list).
        '''

        to_remove = set()
        taskd_keys = TASKD_TEMPLATE.keys()

        for _task_id, _task in copy.copy(self.data[DATA_TASKS]).items():
            if task_id == _task_id:
                pass
            
            if isinstance(_task, Task):
                _task.remove_subtask(task_id)

                if task_id in _task.get_parents(): 
                    to_remove.add(_task_id)

                    for __task_id in _task.get_subtasks():
                        to_remove.add(__task_id)
            elif isinstance(_task, dict):
                if _task.keys() != taskd_keys:
                    to_remove.add(_task_id)
                    continue

                if task_id in _task[TASK_SUBTASKS]:
                    _task[TASK_SUBTASKS].remove(task_id)

                if task_id in _task[TASK_PARENTS]:
                    to_remove.add(_task_id)

                    for __task_id in _task[TASK_SUBTASKS]:
                        to_remove.add(__task_id)
            else:
                to_remove.add(_task_id)
                
        try:
            self.data[DATA_TASKS].pop(task_id) 
        except KeyError: # A nonexistent task, most likely from a subtasks or parents list.
            pass

        for _task_id in to_remove:
            for group_id in self.data[DATA_GROUPS]:
                self.group_remove_task(_task_id, group_id)
            self._deep_remove_task(_task_id)

    def _get_script_dir(self):
        ''' Get the directory of the file that Master object is created from. '''
        dirname, _ = os.path.split(__file__)
        return os.path.abspath(dirname)

    def _groups_task_ids_to(self, type, data):
        ''' Converts task IDs in a group to set or list. 
        
        Raises:
            TypeError
        '''
        
        if not (type == OrderedSet or type == list):
            raise TypeError(f"Invalid type provided: {type}") 

        for group_id in data[DATA_GROUPS].keys():
            data[DATA_GROUPS][group_id][GROUP_TASKS] = type(data[DATA_GROUPS][group_id][GROUP_TASKS])

    def _is_Task(self, task_id):
        ''' Confirms if task ID is a Task object. 
        
        Raises:
            TaskNotFoundError
        '''
        try:
            if isinstance(self.data[DATA_TASKS][task_id], Task):
                return True
            else:
                return False
        except KeyError as e:
            raise TaskNotFoundError(task_id=task_id) from e

    def _is_group(self, group_id):
        ''' Raises GroupNotFoundError if a group does not exist. '''
        
        if not group_id in self.get_groups():
            raise GroupNotFoundError(group_id=group_id)

    def _set_current_id(self, id, type, validate_id=True):
        ''' Sets current task ID or group ID based on provided type. 

            Expected args:
                id: base36-int
                type: str == ["group" | "task"]
                
            validate_id specifis if validation of the provided ID should be performed.
            Unless ID was generated by Master or Task validation is recommended.
        
        Raises:
            TypeError
            ValueError
        '''
        
        if validate_id:
            Task._validate_id(Task, id)

        if type == "task":
            key = DATA_CURRENT_TASK
        elif type == "group":
            key = DATA_CURRENT_GROUP

        self.data[key] = id
        
    def _validate_group_title(self, title):
        ''' Validates group title.

        Raises:
            TypeError
            ValueError
        '''

        if not isinstance(title, str):
            raise TypeError("Group title not of type str.")
        
        if not title:
            raise ValueError("Group title is an empty str.")

        if len(title) >= MAX_GROUP_TITLE_LENGTH:
            raise ValueError(f"Group title '{title[:MAX_GROUP_TITLE_LENGTH]}..' exceeds maximum character length of {MAX_GROUP_TITLE_LENGTH}.")

    def in_group(self, task_id):
        ''' Returns True if task with ID task_id is in a group, else returns False. '''
        for group_id in self.get_groups():
            if task_id in self.get_group_tasks(group_id):
                return True
        return False
        
    def make_subtask(self, subtask_id, task_id):
        ''' Make task with ID 'subtask_id' a subtask of task with ID 'task_id'.

        Prefer this over directly manipulating Task object as this function makes sure that 
        changes are reflected in all other tasks.

        Raises:
            DataError
            TaskNotFoundError
            ValueError
        '''
        if self.in_group(subtask_id):
            raise ValueError(f"Task with ID '{subtask_id}' is in a group. A task cannot be both a subtask and in a group.")
        
        if self._is_recursive_relationship(task_id, subtask_id, "subtasks"):
            raise ValueError(f"A recursive relationship exists between task with ID '{task_id}' and proposed subtask with ID '{subtask_id}'")
        
        task = self.load_task(task_id)
        subtask = self.load_task(subtask_id)

        task.add_subtask(subtask_id)
        subtask.add_parent(task_id)

    def make_parent(self, parent_id, task_id):
        ''' Make task with ID 'parent_id' a parent of task with ID 'task_id'.

        Prefer this over directly manipulating Task object as this function makes sure that 
        changes are reflected in all other tasks.

        Raises:
            DataError
            TaskNotFoundError
            ValueError
        '''
        if self.in_group(task_id):
            raise ValueError(f"Task with ID '{task_id}' is in a group. A task cannot be both a subtask and in a group.")
        
        if self._is_recursive_relationship(task_id, parent_id, "parents"):
            raise ValueError(f"A recursive relationship exists between task with ID '{task_id}' and proposed parent with ID '{parent_id}'")
        
        task = self.load_task(task_id)
        parent = self.load_task(parent_id)

        task.add_parent(parent_id)
        parent.add_subtask(task_id)    

        return True
    
    # TODO: def remove_subtask()
    # TODO: def remove_parent()

    def _is_recursive_relationship(self, origin_id, x_id, check, visited=None):
        '''Checks for a would-be recursive parent or subtask relationship between two tasks.

        Performs a depth-first search starting from `x_id` to determine if
        `origin_id` is found in the specified direction (parents or subtasks)
        at any level of recursion.
        
        Args:
            origin_id (str): The ID of the task to search for.
            x_id (str): The ID of the task from which to start the recursive search.
            check (str): The direction of the search.
                         Must be "parents" to check upwards through parent tasks.
                         Must be "subtasks" to check downwards through subtasks.
            visited (set, optional): Internal parameter used for tracking visited
                                     task IDs during recursion to prevent infinite
                                     loops and detect cycles. Do not pass this directly.

        Returns:
            bool: True if origin_id is found as a recursive parent/subtask,
                  False otherwise.

        Raises:
            DataError
            TaskNotFoundError
        '''
        if not visited:
            visited = set()
                
        if check == "subtasks":
            task_ids = self.get_task(x_id).get_subtasks()
        elif check == "parents":
            task_ids = self.get_task(x_id).get_parents()
        else:
            raise ValueError("'check' must be a str with contents of either 'subtasks' or 'parents'.")

        if origin_id in task_ids:
            return True
        
        if x_id in visited:
            raise DataError(task_id=x_id, msg=f"Task with ID '{x_id}' (not '{origin_id}') has a recursive relationship with another task.") 
        
        visited.add(x_id)
        for _x_id in task_ids:
            if self._is_recursive_relationship(origin_id, _x_id, check, visited):
                return True
        visited.remove(x_id)
        
        return False
        
    def clear_group(self, group_id):
        ''' Clears all task IDs from group. Does not remove the tasks 
        from data.

        Raises:
            GroupNotFoundError
        '''

        self._is_group(group_id)
        self.data[DATA_GROUPS][group_id][GROUP_TASKS] = OrderedSet()
        
    def create_group(self, title=None):
        ''' Creates a new group and returns its group ID. 
        
        Raises:
            TypeError
            ValueError
        '''

        group = copy.deepcopy(GROUP_TEMPLATE)
        if title:
            try:
                self._validate_group_title(title)
            except (ValueError, TypeError) as e:
                raise type(e)(f"Unable to create group with ID: '{group_id}' due to invalid title.\nDetails: {e}") from e
            
            group[GROUP_TITLE] = title

        group_id = increment_id(self.get_current_group_id())
        self.data[DATA_GROUPS][group_id] = group
        self.set_current_group_id(group_id, validate_id=False)
        
        return group_id

    def create_subtask(self, parent_task_id, task_kwargs={}):
        ''' Creates a Task object and adds task ID to subtask 
        attribute of Task object with ID parent_task_id. 
        
        Returns task ID on completion.

        Raises:
            TaskCreationError
            TaskNotFoundError
        '''

        task_id = self.create_task(subtask=True, task_kwargs=task_kwargs)

        try:
            self.load_task(parent_task_id)
        except TaskNotFoundError as e:
            msg = f"Could not make '{task_id}' a subtask of task with ID '{parent_task_id}'.\nAttempting to remove task with ID: '{task_id}'."
            self.remove_task(task_id)        
            raise TaskNotFoundError(task_id=parent_task_id, msg=msg) from e

        self.data[DATA_TASKS][task_id].add_parent(parent_task_id)
        self.data[DATA_TASKS][parent_task_id].add_subtask(task_id)

        return task_id

    def create_task(self, group_id=None, subtask=False, task_kwargs={}):
        ''' Creates a Task object with args in task_kwargs and returns task ID on success. 
        
        Raises:
            GroupNotFoundError
            TaskCreationError
        '''

        if "task_id" in task_kwargs.keys():
            raise TaskCreationError(task_id=task_kwargs["task_id"],
                                    msg="Cannot create task with excplicit task ID. Interact with Task object directly to achieve this, or use Master.load_task() to load an existing task with provided ID.")
        
        if group_id and subtask:
            raise TaskCreationError(task_id=increment_id(self.get_current_task_id()), 
                                    msg="Argument Error: A task cannot be both a subtask and part of a group.")

        try:
            task = Task(master=self, **task_kwargs)
        except (TypeError, ValueError) as e:
            raise TaskCreationError(task_id=increment_id(self.get_current_task_id()), 
                                    msg=f"Error with argument passed to Task.__init__(): '{task_kwargs}'.:\nDetails: {e}") from e

        task_id = task.get_id()
        self.data[DATA_TASKS][task_id] = task

        if group_id:
            try:
                self.group_add_task(task_id, group_id)
            except GroupNotFoundError as e:
                e.task_id = task_id
                e.msg += f"\nTask with ID '{task_id}' was created but not succesfully added to any group."
                raise
            
        return task_id

    def get_active_group(self):
        return self.data[DATA_ACTIVE_GROUP]
    
    def get_current_task_id(self):
        return self.data[DATA_CURRENT_TASK]

    def get_current_group_id(self):
        return self.data[DATA_CURRENT_GROUP]

    def get_group_tasks(self, group_id):
        ''' Returns a list of task IDs in group. 
        
        Raises:
            GroupNotFoundError
        '''
        
        self._is_group(group_id)

        return list(self.data[DATA_GROUPS][group_id][GROUP_TASKS])

    def get_group_title(self, group_id):
        ''' Returns title of group with ID 'group_id' 
        
        Raises:
            GroupNotFoundError
        '''
        self._is_group(group_id)

        return self.data[DATA_GROUPS][group_id][GROUP_TITLE]
    
    def get_groups(self):
        ''' Returns a list of group IDs. '''
        return list(self.data[DATA_GROUPS].keys())
    
    def get_task(self, task_id):
        ''' Loads and returns Task object with ID task_id. 
        
        Raises:
            DataError
            TaskNotFoundError
        '''
        
        self.load_task(task_id)

        return self.data[DATA_TASKS][task_id]

    def get_task_by_title(self, title, ignore_case=True, group_id=None):
        ''' Returns a list of tasks with matching title. If group_id
        is passed only tasks that belong to that group will be 
        returned (recommended).

        If ignore_case is True case is ignored.
        
        Raises:
            DataError
            GroupNotFoundError
            TaskNotFoundError
        '''

        ids = self.get_tasks() if not group_id else self.get_group_tasks(group_id)
        if ignore_case:
            title = title.lower()

        return [task_id for task_id in ids if title ==
                (self.get_task(task_id).get_title().lower() if ignore_case else self.get_task(task_id).get_title())]
            
    def get_tasks(self):
        ''' Returns a list of all task IDs. '''
        return list(self.data[DATA_TASKS].keys())

    def group_add_task(self, task_id, group_id): 
        ''' Adds an existing task ID to a group. 
        
        Raises: 
            DataError
            GroupNotFoundError
            TaskNotFoundError
            ValueError
        '''

        task = self.get_task(task_id)
        
        if task.get_parents():
            error_message = f"Failed to add task with ID '{task_id}' to group with ID '{group_id}'."
            raise ValueError(f"{error_message} A subtask cannot be part of a group.")

        self._is_group(group_id)
        
        self.data[DATA_GROUPS][group_id][GROUP_TASKS].add(task_id)

    def group_remove_task(self, task_id, group_id):
        ''' Removes a task from a group. 
        
        Raises:
            GroupNotFoundError
        '''
        self._is_group(group_id)
        
        try:
            self.data[DATA_GROUPS][group_id][GROUP_TASKS].remove(task_id)
        except KeyError:  # Task is not in group
            return

    def init_storage_file(self):
        ''' Initializes (and if not exists, creates) the storage file. 
        
        Raises:
            DataError
            FSError
        '''

        group = copy.deepcopy(GROUP_TEMPLATE)
        group[GROUP_TITLE] = "General"
        group[GROUP_TASKS] = list(group[GROUP_TASKS])

        storage = {
            DATA_CURRENT_TASK: "0", # IDs are in base 36, hence strings
            DATA_CURRENT_GROUP: "0",
            DATA_ACTIVE_GROUP: "0",
            DATA_GROUPS: {"0": group},
            DATA_TASKS: {} 
        }

        try:
            with open(self.STORAGE_PATH, "w") as f:
                json.dump(storage, f, ensure_ascii=False)
        except FileNotFoundError as e:
            raise FSError(path=self.STORAGE_PATH, msg="A file system error occured during creation of storage file.") from e
        except PermissionError as e:
            raise FSError(path=self.STORAGE_PATH, msg=f"No permission to create storage file. Inspect file permissions for: '{self.STORAGE_PATH}'") from e

        with open(self.STORAGE_PATH, "r") as f:
            try:
                written = json.loads(f.read())
            except json.JSONDecodeError as e:
                raise DataError(path=self.STORAGE_PATH, 
                                msg="An error occured while creating storage file.") from e

            if written == storage:
                self.ui.relay(f"Succesfully initialized storage file at '{self.STORAGE_PATH}'.")
            else:
                raise DataError(path=self.STORAGE_PATH, msg=f"Expected: {storage}\nActual: {written}")

    def load_data(self):
        ''' Loads from storage file to self.data. 
        
        Raises:
            DataError
            FSError
        '''

        data = {}

        try:
            with open(self.STORAGE_PATH, mode='r') as f:
                data = json.loads(f.read())
        except FileNotFoundError as e:
            self.ui.relay(f"Storage file at '{self.STORAGE_PATH}' not found.")
        except json.JSONDecodeError as e:
            raise DataError(path=self.STORAGE_PATH, msg="The data in storage file could not be interpreted.") from e
        except PermissionError as e:
            raise FSError(path=self.STORAGE_PATH, msg=f"No permission to access storage file. Inspect file permissions for: '{self.STORAGE_PATH}'") from e
        except Exception as e:
            raise FSError(path=self.STORAGE_PATH, msg="An unexpected error occurred while loading data.") from e

        if data:
            self.STORAGE_BACKUP = copy.deepcopy(self.data)

            self._groups_task_ids_to(OrderedSet, data)
            self.data = data
        else:
            self.ui.relay(message=f"No data loaded from storage file at: '{self.STORAGE_PATH}'.")
            self.ui.relay(message="Attempting to create a new storage file...")

            self.init_storage_file()
            self.load_data()

    def load_group(self, group_id):
        ''' Converts task dicts to Task objects for tasks in group with ID group_id. 
        
        Raises:
            DataError
            GroupNotFoundError
        '''        
        for task_id in self.get_group_tasks(group_id):
            try:
                self.load_task(task_id)
            except TaskNotFoundError:
                self.group_remove_task(task_id, group_id)
                continue

    def load_task(self, task_id):
        ''' Converts task dict to Task object for task with ID task_id. 
        
        Recursively loads parent and subtasks.
        
        Raises:
            DataError
            TaskNotFoundError
        '''
        
        if self._is_Task(task_id):
            return

        try:
            task = Task(self, 
                        task_id=task_id, 
                        taskd=self.data[DATA_TASKS][task_id])
        except (TypeError, ValueError) as e:
            raise DataError(task_id=increment_id(self.get_current_task_id()), 
                                msg=f"Data in loaded task dict with ID '{task_id}' was invalid.\nDetails: {e}") from e

        self.data[DATA_TASKS][task_id] = task
        
        for subtask_id in self.data[DATA_TASKS][task_id].get_subtasks():
            self.load_task(subtask_id)

        for parent_id in self.data[DATA_TASKS][task_id].get_parents():
            self.load_task(parent_id)
    
    def move_task(self, task_id, steps, group_id=None, parent_task_id=None):
        ''' Moves a task ID 'steps' indices in a group or subtasks list
        and returns the index of task ID. If index would be out of range 
        the current index of task ID is returned without attempting to move
        the task.

        One (and only one) of kwargs group_id or parent_task_id must be provided.

        Raises:
            GroupNotFoundError
            TaskNotFoundError
        '''
        
        if group_id and parent_task_id:
            raise TypeError("Expected group_id or parent_task_id, got both.")

        if group_id:
            if task_id not in self.get_group_tasks(group_id):
                raise TaskNotFoundError(task_id=task_id, msg=f"Task with ID '{task_id}' not found in group with ID '{group_id}'.")
            
            return self.data[DATA_GROUPS][group_id][GROUP_TASKS].move(task_id, steps)
        elif parent_task_id:
            parent = self.get_task(parent_task_id)

            return parent.move_subtask(task_id, steps)
        else:
            raise TypeError("Expected group_id or parent_task_id, got neither.")

    def orphan_task(self, task_id):
        ''' Removes a task from all parents' subtask attribute. 

        Raises:
            DataError
            TaskNotFoundError
        '''
        self.load_task(task_id)
        
        for parent_id in self.data[DATA_TASKS][task_id].get_parents():
            self.data[DATA_TASKS][parent_id].remove_subtask(task_id)

    def remove_task(self, task_id, subtask=False):
        ''' Removes a task from all groups, orphans the task 
        and recursively removes all of its subtaskts.

        Raises:
            DataError
            TaskNotFoundError
        '''

        if not subtask:
            for group_id in self.data[DATA_GROUPS].keys():
                self.group_remove_task(task_id, group_id)

        try:
            self.load_task(task_id)
        except (TaskNotFoundError, DataError) as e: 
            # Indicates failure to load task (OR its parents/subtasks, which indicates data corruption).
            self._deep_remove_task(task_id)
            raise type(e)(msg=f"An attempt has been made to remove mention of task with ID '{task_id}' from groups, parents and subtasks lists and all of its children (if any).", 
                          task_id=e.task_id) from e

        self.orphan_task(task_id)
        
        for subtask_id in self.data[DATA_TASKS][task_id].get_subtasks():
            try:
                self.remove_task(subtask_id, subtask=True)
            except TaskNotFoundError:
                pass

        self.data[DATA_TASKS].pop(task_id)
    
    def remove_group(self, group_id):
        ''' Removes group with group ID group_id. Tasks are left without a group unless explicitly moved first. 
        
        Raises:
            GroupNotFoundError
        '''
        self._is_group(group_id)
        self.data[DATA_GROUPS].pop(group_id)
        
    def set_active_group(self, group_id):
        ''' Sets the active group, loading all of its tasks. 
        
        Raises:
            DataError
            GroupNotFoundError
        '''

        if self.get_active_group() != group_id:
            self.load_group(group_id)

            self.data[DATA_ACTIVE_GROUP] = group_id

    def set_current_group_id(self, group_id, validate_id=True):
        ''' Set current group ID to 'id'. 
        
        Raises:
            TypeError
            ValueError
        '''

        self._set_current_id(group_id, "group", validate_id=validate_id)

    def set_current_task_id(self, task_id, validate_id=True):
        ''' Set current task ID to 'id'. 
        
        Raises:
            TypeError
            ValueError
        '''        
        
        self._set_current_id(task_id, "task", validate_id=validate_id)

    def set_group_title(self, group_id, title):
        ''' Sets group title.
        
        Raises:
            GroupNotFoundError
            TypeError
            ValueError
        '''

        self._is_group(group_id)        

        try:
            self._validate_group_title(title)
        except (ValueError, TypeError) as e:
            raise type(e)(f" Invalid title for group: '{group_id}'.\nDetails: {e}") from e
        
        self.data[DATA_GROUPS][group_id][GROUP_TITLE] = title

    def write_data(self): 
        ''' Writes self.data to storage file. 
        
        Raises:
            FSError
        '''

        data = copy.deepcopy(self.data)

        self._groups_task_ids_to(list, data)

        for task_id, task in self.data[DATA_TASKS].items():
            if self._is_Task(task_id): # If Task object, convert to task dict
                data[DATA_TASKS][task_id] = task.write_dict()
        
        try:
            with open(self.STORAGE_PATH, mode='w') as f:
                json.dump(data, f, ensure_ascii=False)
        except FileNotFoundError as e:
            raise FSError(path=self.STORAGE_PATH, msg=f"No file found at: '{self.STORAGE_PATH}'") from e
        except PermissionError as e:
            raise FSError(path=self.STORAGE_PATH, msg=f"No permission to write to storage file. Inspect file permissions for: '{self.STORAGE_PATH}'") from e
        except Exception as e:
            raise FSError(path=self.STORAGE_PATH, msg=f"An unexpected error occured during attempt to write data to storage file at: '{self.STORAGE_PATH}'") from e

        self.STORAGE_BACKUP = copy.deepcopy(data)
        
if __name__ == '__main__':
    class DevUI:
        ''' Simple frontend for development purposes. 
        
        Serves as example for other frontends. Frontends must define the function headers defined here.   
        '''

        def relay(self, message=''):
            ''' Relays a message to the user. '''
            print(message)
        
        def request(self, request_type=bool, message=''):
            ''' Requests information from the user. '''
            def prompt_user(prompt):
                u_in = ''
                while not u_in:
                    u_in = input(prompt)
                return u_in

            print("Please provide:", message)

            if request_type is bool:
                if prompt_user("(Y/n)> ").lower().startswith('y'):
                    return True
                else:
                    return False
            elif request_type is str:                
                return prompt_user("> ")
            elif request_type is int:
                u_in = ''
                while not u_in.isdecimal():
                    u_in = prompt_user("> ")
                return int(u_in)

    master = Master(DevUI())